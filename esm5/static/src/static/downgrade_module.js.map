{"version":3,"file":"downgrade_module.js","sourceRoot":"","sources":["../../../../../../../packages/upgrade/static/src/static/downgrade_module.ts"],"names":[],"mappings":";;;;;;;;;;;AASA,OAAO,EAAC,eAAe,EAAC,MAAM,2BAA2B,CAAC;AAE1D,OAAO,KAAK,OAAO,MAAM,oBAAoB,CAAC;AAC9C,OAAO,EAAC,SAAS,EAAE,QAAQ,EAAE,2BAA2B,EAAE,YAAY,EAAE,eAAe,EAAE,oBAAoB,EAAE,mBAAmB,EAAC,MAAM,qBAAqB,CAAC;AAC/J,OAAO,EAAgC,wBAAwB,EAAE,UAAU,EAAC,MAAM,gBAAgB,CAAC;AAEnG,OAAO,EAAC,iBAAiB,EAAE,kBAAkB,EAAC,MAAM,sBAAsB,CAAC;AAC3E,OAAO,EAAC,iBAAiB,EAAC,MAAM,QAAQ,CAAC;;AAGzC,IAAI,SAAS,GAAG,CAAC,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsFlB,MAAM,UAAU,eAAe,CAC3B,0BAC+D;;IACjE,IAAM,cAAc,GAAM,mBAAmB,aAAQ,EAAE,SAAW,CAAC;;IACnE,IAAM,gBAAgB,GAAG,KAAG,eAAe,GAAG,cAAgB,CAAC;;IAC/D,IAAM,eAAe,GAAG,KAAG,YAAY,GAAG,cAAgB,CAAC;;IAE3D,IAAM,WAAW,GAAG,UAAU,CAAC,0BAA0B,CAAC,CAAC,CAAC;QACxD,0BAA0B,CAAC,CAAC;QAC5B,UAAC,cAAgC;YAC7B,OAAA,eAAe,CAAC,cAAc,CAAC,CAAC,sBAAsB,CAAC,0BAA0B,CAAC;QAAlF,CAAkF,CAAC;;IAE3F,IAAI,QAAQ,CAAW;;IAGvB,OAAO,CAAC,MAAM,CAAC,cAAc,EAAE,EAAE,CAAC;SAC7B,QAAQ,CAAC,oBAAoB,eAAsB;SACnD,OAAO,CAAC,YAAY,EAAE,CAAC,eAAe,EAAE,QAAQ,CAAC,CAAC;SAClD,OAAO,CACJ,eAAe,EACf;QACE,IAAI,CAAC,QAAQ,EAAE;YACb,MAAM,IAAI,KAAK,CACX,4EAA4E;gBAC5E,iBAAiB,CAAC,CAAC;SACxB;QACD,OAAO,QAAQ,CAAC;KACjB,CAAC;SACL,OAAO,CAAC,eAAe,EAAE,CAAC,gBAAgB,EAAE,QAAQ,CAAC,CAAC;SACtD,OAAO,CACJ,gBAAgB,EAChB;QACE,SAAS;QACT,UAAC,SAAmC;YAClC,kBAAkB,CAAC,SAAS,CAAC,CAAC;;YAC9B,IAAM,MAAM,GAAkB;gBAC5B,WAAW,EAAE,IAAI;gBACjB,OAAO,EAAE,WAAW,CAAC,iBAAiB,CAAC,CAAC,IAAI,CAAC,UAAA,GAAG;oBAC9C,QAAQ,GAAG,MAAM,CAAC,QAAQ,GAAG,IAAI,iBAAiB,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;oBACjE,QAAQ,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;oBAExB,OAAO,QAAQ,CAAC;iBACjB,CAAC;aACH,CAAC;YACF,OAAO,MAAM,CAAC;SACf;KACF,CAAC;SACL,MAAM,CAAC;QACN,SAAS,EAAE,QAAQ;QACnB,UAAC,SAAmC,EAAE,QAAiC;YACrE,QAAQ,CAAC,QAAQ,CAAC,2BAA2B,EAAE,wBAAwB,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,CAAC;SACzF;KACF,CAAC,CAAC;IAEP,OAAO,cAAc,CAAC;CACvB;;;;;;AAED,SAAS,QAAQ,CAAU,CAAI;IAC7B,OAAO,CAAC,CAAC;CACV","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Injector, NgModuleFactory, NgModuleRef, StaticProvider} from '@angular/core';\nimport {platformBrowser} from '@angular/platform-browser';\n\nimport * as angular from '../common/angular1';\nimport {$INJECTOR, $PROVIDE, DOWNGRADED_MODULE_COUNT_KEY, INJECTOR_KEY, LAZY_MODULE_REF, UPGRADE_APP_TYPE_KEY, UPGRADE_MODULE_NAME} from '../common/constants';\nimport {LazyModuleRef, UpgradeAppType, getDowngradedModuleCount, isFunction} from '../common/util';\n\nimport {angular1Providers, setTempInjectorRef} from './angular1_providers';\nimport {NgAdapterInjector} from './util';\n\n\nlet moduleUid = 0;\n\n/**\n * @description\n *\n * A helper function for creating an AngularJS module that can bootstrap an Angular module\n * \"on-demand\" (possibly lazily) when a {@link downgradeComponent downgraded component} needs to be\n * instantiated.\n *\n * *Part of the [upgrade/static](api?query=upgrade/static) library for hybrid upgrade apps that\n * support AoT compilation.*\n *\n * It allows loading/bootstrapping the Angular part of a hybrid application lazily and not having to\n * pay the cost up-front. For example, you can have an AngularJS application that uses Angular for\n * specific routes and only instantiate the Angular modules if/when the user visits one of these\n * routes.\n *\n * The Angular module will be bootstrapped once (when requested for the first time) and the same\n * reference will be used from that point onwards.\n *\n * `downgradeModule()` requires either an `NgModuleFactory` or a function:\n * - `NgModuleFactory`: If you pass an `NgModuleFactory`, it will be used to instantiate a module\n *   using `platformBrowser`'s {@link PlatformRef#bootstrapModuleFactory bootstrapModuleFactory()}.\n * - `Function`: If you pass a function, it is expected to return a promise resolving to an\n *   `NgModuleRef`. The function is called with an array of extra {@link StaticProvider Providers}\n *   that are expected to be available from the returned `NgModuleRef`'s `Injector`.\n *\n * `downgradeModule()` returns the name of the created AngularJS wrapper module. You can use it to\n * declare a dependency in your main AngularJS module.\n *\n * {@example upgrade/static/ts/lite/module.ts region=\"basic-how-to\"}\n *\n * For more details on how to use `downgradeModule()` see\n * [Upgrading for Performance](guide/upgrade-performance).\n *\n * @usageNotes\n *\n * Apart from `UpgradeModule`, you can use the rest of the `upgrade/static` helpers as usual to\n * build a hybrid application. Note that the Angular pieces (e.g. downgraded services) will not be\n * available until the downgraded module has been bootstrapped, i.e. by instantiating a downgraded\n * component.\n *\n * <div class=\"alert is-important\">\n *\n *   You cannot use `downgradeModule()` and `UpgradeModule` in the same hybrid application.<br />\n *   Use one or the other.\n *\n * </div>\n *\n * ### Differences with `UpgradeModule`\n *\n * Besides their different API, there are two important internal differences between\n * `downgradeModule()` and `UpgradeModule` that affect the behavior of hybrid applications:\n *\n * 1. Unlike `UpgradeModule`, `downgradeModule()` does not bootstrap the main AngularJS module\n *    inside the {@link NgZone Angular zone}.\n * 2. Unlike `UpgradeModule`, `downgradeModule()` does not automatically run a\n *    [$digest()](https://docs.angularjs.org/api/ng/type/$rootScope.Scope#$digest) when changes are\n *    detected in the Angular part of the application.\n *\n * What this means is that applications using `UpgradeModule` will run change detection more\n * frequently in order to ensure that both frameworks are properly notified about possible changes.\n * This will inevitably result in more change detection runs than necessary.\n *\n * `downgradeModule()`, on the other side, does not try to tie the two change detection systems as\n * tightly, restricting the explicit change detection runs only to cases where it knows it is\n * necessary (e.g. when the inputs of a downgraded component change). This improves performance,\n * especially in change-detection-heavy applications, but leaves it up to the developer to manually\n * notify each framework as needed.\n *\n * For a more detailed discussion of the differences and their implications, see\n * [Upgrading for Performance](guide/upgrade-performance).\n *\n * <div class=\"alert is-helpful\">\n *\n *   You can manually trigger a change detection run in AngularJS using\n *   [scope.$apply(...)](https://docs.angularjs.org/api/ng/type/$rootScope.Scope#$apply) or\n *   [$rootScope.$digest()](https://docs.angularjs.org/api/ng/type/$rootScope.Scope#$digest).\n *\n *   You can manually trigger a change detection run in Angular using {@link NgZone#run\n *   ngZone.run(...)}.\n *\n * </div>\n *\n * @publicApi\n */\nexport function downgradeModule<T>(\n    moduleFactoryOrBootstrapFn: NgModuleFactory<T>|\n    ((extraProviders: StaticProvider[]) => Promise<NgModuleRef<T>>)): string {\n  const lazyModuleName = `${UPGRADE_MODULE_NAME}.lazy${++moduleUid}`;\n  const lazyModuleRefKey = `${LAZY_MODULE_REF}${lazyModuleName}`;\n  const lazyInjectorKey = `${INJECTOR_KEY}${lazyModuleName}`;\n\n  const bootstrapFn = isFunction(moduleFactoryOrBootstrapFn) ?\n      moduleFactoryOrBootstrapFn :\n      (extraProviders: StaticProvider[]) =>\n          platformBrowser(extraProviders).bootstrapModuleFactory(moduleFactoryOrBootstrapFn);\n\n  let injector: Injector;\n\n  // Create an ng1 module to bootstrap.\n  angular.module(lazyModuleName, [])\n      .constant(UPGRADE_APP_TYPE_KEY, UpgradeAppType.Lite)\n      .factory(INJECTOR_KEY, [lazyInjectorKey, identity])\n      .factory(\n          lazyInjectorKey,\n          () => {\n            if (!injector) {\n              throw new Error(\n                  'Trying to get the Angular injector before bootstrapping the corresponding ' +\n                  'Angular module.');\n            }\n            return injector;\n          })\n      .factory(LAZY_MODULE_REF, [lazyModuleRefKey, identity])\n      .factory(\n          lazyModuleRefKey,\n          [\n            $INJECTOR,\n            ($injector: angular.IInjectorService) => {\n              setTempInjectorRef($injector);\n              const result: LazyModuleRef = {\n                needsNgZone: true,\n                promise: bootstrapFn(angular1Providers).then(ref => {\n                  injector = result.injector = new NgAdapterInjector(ref.injector);\n                  injector.get($INJECTOR);\n\n                  return injector;\n                })\n              };\n              return result;\n            }\n          ])\n      .config([\n        $INJECTOR, $PROVIDE,\n        ($injector: angular.IInjectorService, $provide: angular.IProvideService) => {\n          $provide.constant(DOWNGRADED_MODULE_COUNT_KEY, getDowngradedModuleCount($injector) + 1);\n        }\n      ]);\n\n  return lazyModuleName;\n}\n\nfunction identity<T = any>(x: T): T {\n  return x;\n}\n"]}