{"version":3,"file":"angular1.js","sourceRoot":"","sources":["../../../../../../packages/upgrade/static/src/common/angular1.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6NA,SAAS,IAAI;IACX,MAAM,IAAI,KAAK,CAAC,+BAA+B,CAAC,CAAC;CAClD;WAE4C,GAAG,EAAE,CAAC,IAAI,EAAE;;AAAzD,MAAM,WAAW,qBAA2B,IAAqB,EAAC;AAClE,WAAW,CAAC,SAAS,GAAG,IAAI,CAAC;;AAE7B,IAAI,OAAO,GAWP;IACF,SAAS,EAAE,IAAI;IACf,MAAM,EAAE,IAAI;IACZ,OAAO,EAAE,WAAW;IACpB,OAAO,oBAAE,SAAgB,CAAA;IACzB,eAAe,EAAE,IAAI;IACrB,cAAc,EAAE,IAAI;CACrB,CAAC;AAEF,IAAI;IACF,IAAI,MAAM,CAAC,cAAc,CAAC,SAAS,CAAC,EAAE;QACpC,OAAO,GAAG,mBAAM,MAAM,EAAC,CAAC,OAAO,CAAC;KACjC;CACF;AAAC,OAAO,CAAC,EAAE;;CAEX;;;;;;;;AAOD,MAAM,UAAU,aAAa,CAAC,EAAO;IACnC,kBAAkB,CAAC,EAAE,CAAC,CAAC;CACxB;;;;;;;AAOD,MAAM,UAAU,aAAa;IAC3B,OAAO,kBAAkB,EAAE,CAAC;CAC7B;;;;;;;;;;AASD,MAAM,UAAU,kBAAkB,CAAC,EAAO;IACxC,OAAO,GAAG,EAAE,CAAC;IACb,OAAO,GAAG,EAAE,IAAI,EAAE,CAAC,OAAO,CAAC;CAC5B;;;;;;;AAOD,MAAM,UAAU,kBAAkB;IAChC,OAAO,OAAO,CAAC;CAChB;;AAED,aAAa,SAAS,GAA6B,CAAC,CAAC,EAAE,OAAO,EAAE,MAAO,EAAE,EAAE,CACvE,OAAO,CAAC,SAAS,CAAC,CAAC,EAAE,OAAO,EAAE,MAAM,CAAC,CAAC;;AAE1C,aAAa,MAAM,GAA0B,CAAC,MAAM,EAAE,YAAa,EAAE,EAAE,CACnE,OAAO,CAAC,MAAM,CAAC,MAAM,EAAE,YAAY,CAAC,CAAC;;AAEzC,aAAa,OAAO,qBAA2B,CAAC,CAAC,CAAC,EAAE,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,CAAC,CAA2B,EAAC;AACnG,OAAO,CAAC,SAAS,GAAG,KAAK,CAAC,EAAE,CAAC,OAAO,CAAC,OAAO,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;;AAE9D,aAAa,eAAe,GAAmC,GAAG,EAAE,CAAC,OAAO,CAAC,eAAe,EAAE,CAAC;;AAE/F,aAAa,cAAc,GAAkC,CAAC,CAAC,EAAE,CAAC,OAAO,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC;;AAE5F,WAAW,OAAO,GAAG,OAAO,CAAC,OAAO,CAAC","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nexport type Ng1Token = string;\n\nexport type Ng1Expression = string | Function;\n\nexport interface IAnnotatedFunction extends Function {\n  // Older versions of `@types/angular` typings extend the global `Function` interface with\n  // `$inject?: string[]`, which is not compatible with `$inject?: ReadonlyArray<string>` (used in\n  // latest versions).\n  $inject?: Function extends{$inject?: string[]}? Ng1Token[]: ReadonlyArray<Ng1Token>;\n}\n\nexport type IInjectable = (Ng1Token | Function)[] | IAnnotatedFunction;\n\nexport type SingleOrListOrMap<T> = T | T[] | {[key: string]: T};\n\nexport interface IModule {\n  name: string;\n  requires: (string|IInjectable)[];\n  config(fn: IInjectable): IModule;\n  directive(selector: string, factory: IInjectable): IModule;\n  component(selector: string, component: IComponent): IModule;\n  controller(name: string, type: IInjectable): IModule;\n  factory(key: Ng1Token, factoryFn: IInjectable): IModule;\n  value(key: Ng1Token, value: any): IModule;\n  constant(token: Ng1Token, value: any): IModule;\n  run(a: IInjectable): IModule;\n}\nexport interface ICompileService {\n  (element: Element|NodeList|Node[]|string, transclude?: Function): ILinkFn;\n}\nexport interface ILinkFn {\n  (scope: IScope, cloneAttachFn?: ICloneAttachFunction, options?: ILinkFnOptions): IAugmentedJQuery;\n  $$slots?: {[slotName: string]: ILinkFn};\n}\nexport interface ILinkFnOptions {\n  parentBoundTranscludeFn?: Function;\n  transcludeControllers?: {[key: string]: any};\n  futureParentElement?: Node;\n}\nexport interface IRootScopeService {\n  $new(isolate?: boolean): IScope;\n  $id: string;\n  $parent: IScope;\n  $root: IScope;\n  $watch(exp: Ng1Expression, fn?: (a1?: any, a2?: any) => void): Function;\n  $on(event: string, fn?: (event?: any, ...args: any[]) => void): Function;\n  $destroy(): any;\n  $apply(exp?: Ng1Expression): any;\n  $digest(): any;\n  $evalAsync(exp: Ng1Expression, locals?: any): void;\n  $on(event: string, fn?: (event?: any, ...args: any[]) => void): Function;\n  $$childTail: IScope;\n  $$childHead: IScope;\n  $$nextSibling: IScope;\n  [key: string]: any;\n}\nexport interface IScope extends IRootScopeService {}\n\nexport interface IAngularBootstrapConfig { strictDi?: boolean; }\nexport interface IDirective {\n  compile?: IDirectiveCompileFn;\n  controller?: IController;\n  controllerAs?: string;\n  bindToController?: boolean|{[key: string]: string};\n  link?: IDirectiveLinkFn|IDirectivePrePost;\n  name?: string;\n  priority?: number;\n  replace?: boolean;\n  require?: DirectiveRequireProperty;\n  restrict?: string;\n  scope?: boolean|{[key: string]: string};\n  template?: string|Function;\n  templateUrl?: string|Function;\n  templateNamespace?: string;\n  terminal?: boolean;\n  transclude?: DirectiveTranscludeProperty;\n}\nexport type DirectiveRequireProperty = SingleOrListOrMap<string>;\nexport type DirectiveTranscludeProperty = boolean | 'element' | {[key: string]: string};\nexport interface IDirectiveCompileFn {\n  (templateElement: IAugmentedJQuery, templateAttributes: IAttributes,\n   transclude: ITranscludeFunction): IDirectivePrePost;\n}\nexport interface IDirectivePrePost {\n  pre?: IDirectiveLinkFn;\n  post?: IDirectiveLinkFn;\n}\nexport interface IDirectiveLinkFn {\n  (scope: IScope, instanceElement: IAugmentedJQuery, instanceAttributes: IAttributes,\n   controller: any, transclude: ITranscludeFunction): void;\n}\nexport interface IComponent {\n  bindings?: {[key: string]: string};\n  controller?: string|IInjectable;\n  controllerAs?: string;\n  require?: DirectiveRequireProperty;\n  template?: string|Function;\n  templateUrl?: string|Function;\n  transclude?: DirectiveTranscludeProperty;\n}\nexport interface IAttributes {\n  $observe(attr: string, fn: (v: string) => void): void;\n  [key: string]: any;\n}\nexport interface ITranscludeFunction {\n  // If the scope is provided, then the cloneAttachFn must be as well.\n  (scope: IScope, cloneAttachFn: ICloneAttachFunction): IAugmentedJQuery;\n  // If one argument is provided, then it's assumed to be the cloneAttachFn.\n  (cloneAttachFn?: ICloneAttachFunction): IAugmentedJQuery;\n}\nexport interface ICloneAttachFunction {\n  // Let's hint but not force cloneAttachFn's signature\n  (clonedElement?: IAugmentedJQuery, scope?: IScope): any;\n}\nexport type IAugmentedJQuery = Node[] & {\n  on?: (name: string, fn: () => void) => void;\n  data?: (name: string, value?: any) => any;\n  text?: () => string;\n  inheritedData?: (name: string, value?: any) => any;\n  contents?: () => IAugmentedJQuery;\n  parent?: () => IAugmentedJQuery;\n  empty?: () => void;\n  append?: (content: IAugmentedJQuery | string) => IAugmentedJQuery;\n  controller?: (name: string) => any;\n  isolateScope?: () => IScope;\n  injector?: () => IInjectorService;\n  triggerHandler?: (eventTypeOrObject: string | Event, extraParameters?: any[]) => IAugmentedJQuery;\n  remove?: () => void;\n  removeData?: () => void;\n};\nexport interface IProvider { $get: IInjectable; }\nexport interface IProvideService {\n  provider(token: Ng1Token, provider: IProvider): IProvider;\n  factory(token: Ng1Token, factory: IInjectable): IProvider;\n  service(token: Ng1Token, type: IInjectable): IProvider;\n  value(token: Ng1Token, value: any): IProvider;\n  constant(token: Ng1Token, value: any): void;\n  decorator(token: Ng1Token, factory: IInjectable): void;\n}\nexport interface IParseService { (expression: string): ICompiledExpression; }\nexport interface ICompiledExpression {\n  (context: any, locals: any): any;\n  assign?: (context: any, value: any) => any;\n}\nexport interface IHttpBackendService {\n  (method: string, url: string, post?: any, callback?: Function, headers?: any, timeout?: number,\n   withCredentials?: boolean): void;\n}\nexport interface ICacheObject {\n  put<T>(key: string, value?: T): T;\n  get(key: string): any;\n}\nexport interface ITemplateCacheService extends ICacheObject {}\nexport interface ITemplateRequestService {\n  (template: string|any /* TrustedResourceUrl */, ignoreRequestError?: boolean): Promise<string>;\n  totalPendingRequests: number;\n}\nexport type IController = string | IInjectable;\nexport interface IControllerService {\n  (controllerConstructor: IController, locals?: any, later?: any, ident?: any): any;\n  (controllerName: string, locals?: any): any;\n}\n\nexport interface IInjectorService {\n  get(key: string): any;\n  has(key: string): boolean;\n}\n\nexport interface IIntervalService {\n  (func: Function, delay: number, count?: number, invokeApply?: boolean,\n   ...args: any[]): Promise<any>;\n  cancel(promise: Promise<any>): boolean;\n}\n\nexport interface ITestabilityService {\n  findBindings(element: Element, expression: string, opt_exactMatch?: boolean): Element[];\n  findModels(element: Element, expression: string, opt_exactMatch?: boolean): Element[];\n  getLocation(): string;\n  setLocation(url: string): void;\n  whenStable(callback: Function): void;\n}\n\nexport interface INgModelController {\n  $render(): void;\n  $isEmpty(value: any): boolean;\n  $setValidity(validationErrorKey: string, isValid: boolean): void;\n  $setPristine(): void;\n  $setDirty(): void;\n  $setUntouched(): void;\n  $setTouched(): void;\n  $rollbackViewValue(): void;\n  $validate(): void;\n  $commitViewValue(): void;\n  $setViewValue(value: any, trigger: string): void;\n\n  $viewValue: any;\n  $modelValue: any;\n  $parsers: Function[];\n  $formatters: Function[];\n  $validators: {[key: string]: Function};\n  $asyncValidators: {[key: string]: Function};\n  $viewChangeListeners: Function[];\n  $error: Object;\n  $pending: Object;\n  $untouched: boolean;\n  $touched: boolean;\n  $pristine: boolean;\n  $dirty: boolean;\n  $valid: boolean;\n  $invalid: boolean;\n  $name: string;\n}\n\nfunction noNg(): never {\n  throw new Error('AngularJS v1.x is not loaded!');\n}\n\nconst noNgElement: typeof angular.element = (() => noNg()) as any;\nnoNgElement.cleanData = noNg;\n\nlet angular: {\n  bootstrap: (e: Element, modules: (string | IInjectable)[], config?: IAngularBootstrapConfig) =>\n                 IInjectorService,\n  module: (prefix: string, dependencies?: string[]) => IModule,\n  element: {\n    (e: string | Element | Document | IAugmentedJQuery): IAugmentedJQuery;\n    cleanData: (nodes: Node[] | NodeList) => void;\n  },\n  version: {major: number},\n  resumeBootstrap: () => void,\n  getTestability: (e: Element) => ITestabilityService\n} = {\n  bootstrap: noNg,\n  module: noNg,\n  element: noNgElement,\n  version: undefined as any,\n  resumeBootstrap: noNg,\n  getTestability: noNg\n};\n\ntry {\n  if (window.hasOwnProperty('angular')) {\n    angular = (<any>window).angular;\n  }\n} catch (e) {\n  // ignore in CJS mode.\n}\n\n/**\n * @deprecated Use `setAngularJSGlobal` instead.\n *\n * @publicApi\n */\nexport function setAngularLib(ng: any): void {\n  setAngularJSGlobal(ng);\n}\n\n/**\n * @deprecated Use `getAngularJSGlobal` instead.\n *\n * @publicApi\n */\nexport function getAngularLib(): any {\n  return getAngularJSGlobal();\n}\n\n/**\n * Resets the AngularJS global.\n *\n * Used when AngularJS is loaded lazily, and not available on `window`.\n *\n * @publicApi\n */\nexport function setAngularJSGlobal(ng: any): void {\n  angular = ng;\n  version = ng && ng.version;\n}\n\n/**\n * Returns the current AngularJS global.\n *\n * @publicApi\n */\nexport function getAngularJSGlobal(): any {\n  return angular;\n}\n\nexport const bootstrap: typeof angular.bootstrap = (e, modules, config?) =>\n    angular.bootstrap(e, modules, config);\n\nexport const module: typeof angular.module = (prefix, dependencies?) =>\n    angular.module(prefix, dependencies);\n\nexport const element: typeof angular.element = (e => angular.element(e)) as typeof angular.element;\nelement.cleanData = nodes => angular.element.cleanData(nodes);\n\nexport const resumeBootstrap: typeof angular.resumeBootstrap = () => angular.resumeBootstrap();\n\nexport const getTestability: typeof angular.getTestability = e => angular.getTestability(e);\n\nexport let version = angular.version;\n"]}